<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ingl√™s R√°pido ‚Äî Turbo</title>
  <style>
    :root{
      --bg:#020617;
      --card:#0b1226;
      --stroke:#1f2a44;
      --text:#e5e7eb;
      --muted:#9ca3af;
      --green:#22c55e;
      --red:#ef4444;
      --blue:#3b82f6;
      --yellow:#f59e0b;
      --shadow: 0 12px 32px rgba(0,0,0,.45);
      --radius: 16px;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;
      background: radial-gradient(1200px 700px at 30% 0%, rgba(59,130,246,.22), transparent 55%),
                  radial-gradient(900px 600px at 80% 10%, rgba(34,197,94,.18), transparent 55%),
                  var(--bg);
      color: var(--text);
    }
    .app{ max-width: 1050px; margin:0 auto; padding: 16px; }
    header{
      display:flex; align-items:center; justify-content:space-between;
      gap:12px; padding: 10px 2px 16px;
    }
    .brand{
      display:flex; align-items:center; gap:10px;
    }
    .logo{
      width:36px;height:36px;border-radius:12px;
      background: linear-gradient(135deg,var(--blue),var(--green));
      box-shadow: var(--shadow);
    }
    .brand h1{ font-size:16px; margin:0; }
    .brand .sub{ font-size:12px; color:var(--muted); margin-top:2px; }
    nav{ display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end; }
    button{
      border:1px solid var(--stroke);
      background: rgba(11,18,38,.7);
      color: var(--text);
      border-radius: 999px;
      padding: 8px 12px;
      cursor:pointer;
      font-weight:600;
      transition: transform .06s ease, background .15s ease, border-color .15s ease;
      user-select:none;
    }
    button:active{ transform: scale(.98); }
    button.primary{
      border:none;
      background: linear-gradient(135deg,var(--blue),var(--green));
      color:#07111f;
      box-shadow: 0 10px 30px rgba(59,130,246,.25);
    }
    button.danger{
      border:none;
      background: linear-gradient(135deg,var(--red),#fb7185);
      color:#1a0a0a;
    }
    button.ghost{
      background: transparent;
    }
    button.active{
      border-color: rgba(34,197,94,.55);
      background: rgba(34,197,94,.10);
    }
    .grid{ display:grid; gap:12px; }
    @media(min-width:860px){ .grid.two{ grid-template-columns: 1.5fr 1fr; } }
    .card{
      background: rgba(11,18,38,.55);
      border:1px solid var(--stroke);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 14px;
    }
    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .space{ justify-content:space-between; }
    .pill{
      display:inline-flex; align-items:center; gap:6px;
      padding: 5px 10px;
      border:1px solid var(--stroke);
      border-radius: 999px;
      color: var(--muted);
      font-size: 12px;
      background: rgba(2,6,23,.35);
    }
    .pill strong{ color: var(--text); font-weight:700; }
    .stats{
      display:grid;
      grid-template-columns: repeat(3, 1fr);
      gap:10px;
    }
    @media(max-width:520px){ .stats{ grid-template-columns: 1fr; } }
    .stat{
      padding:12px;
      border-radius: var(--radius);
      border:1px solid var(--stroke);
      background: rgba(2,6,23,.35);
      text-align:center;
    }
    .stat .k{ font-size:11px; color:var(--muted); letter-spacing:.12em; text-transform:uppercase; }
    .stat .v{ font-size:18px; font-weight:800; margin-top:4px; }
    .progress{
      height: 10px;
      border-radius: 999px;
      background: rgba(2,6,23,.35);
      border:1px solid var(--stroke);
      overflow:hidden;
    }
    .progress > div{
      height:100%;
      width:0%;
      background: linear-gradient(90deg,var(--green),var(--blue));
      transition: width .2s ease;
    }
    .muted{ color: var(--muted); font-size: 12px; }
    .h2{ font-size: 15px; font-weight:800; margin:0; }
    .h3{ font-size: 13px; font-weight:800; margin:0; }
    .screen{ display:none; }
    .screen.active{ display:block; }
    .qwrap{
      border-radius: var(--radius);
      border:1px solid var(--stroke);
      background: rgba(2,6,23,.35);
      padding: 12px;
      margin-top: 10px;
    }
    .qmeta{
      display:flex; gap:8px; flex-wrap:wrap; align-items:center; justify-content:space-between;
      margin-bottom: 8px;
    }
    .tag{
      display:inline-flex;
      align-items:center; gap:6px;
      font-size:12px;
      padding: 4px 10px;
      border-radius: 999px;
      border:1px solid var(--stroke);
      background: rgba(11,18,38,.55);
      color: var(--muted);
    }
    .tag b{ color: var(--text); }
    .big{
      font-size: 16px;
      font-weight:800;
      margin: 6px 0 0;
      line-height: 1.25;
    }
    .prompt{
      font-size: 13px;
      color: var(--text);
      margin-top: 6px;
      line-height: 1.35;
    }
    .en{
      font-size: 14px;
      font-weight:800;
      margin-top: 8px;
      padding: 10px;
      border-radius: 12px;
      border: 1px dashed rgba(148,163,184,.35);
      background: rgba(2,6,23,.25);
    }
    .options{ margin-top: 10px; display:grid; gap:8px; }
    .opt{
      text-align:left;
      border-radius: 999px;
      padding: 10px 12px;
      border:1px solid var(--stroke);
      background: rgba(11,18,38,.55);
      font-weight:700;
      cursor:pointer;
    }
    .opt:hover{ border-color: rgba(96,165,250,.55); }
    .opt.correct{ border-color: rgba(34,197,94,.75); background: rgba(34,197,94,.12); }
    .opt.wrong{ border-color: rgba(239,68,68,.75); background: rgba(239,68,68,.12); }
    .feedback{
      margin-top: 10px;
      border-radius: 14px;
      border: 1px solid var(--stroke);
      background: rgba(11,18,38,.45);
      padding: 10px;
      font-size: 13px;
      line-height: 1.35;
    }
    .feedback.good{ border-color: rgba(34,197,94,.55); }
    .feedback.bad{ border-color: rgba(239,68,68,.55); }
    .flash{
      position: fixed;
      inset: 0;
      pointer-events:none;
      opacity:0;
      transition: opacity .14s ease;
    }
    .flash.good{ background: rgba(34,197,94,.14); }
    .flash.bad{ background: rgba(239,68,68,.14); }
    .flash.show{ opacity: 1; }
    .inputRow{
      display:flex; gap:8px; flex-wrap:wrap; margin-top: 10px; align-items:center;
    }
    input[type="text"], textarea{
      width:100%;
      border-radius: 14px;
      border:1px solid var(--stroke);
      background: rgba(2,6,23,.35);
      color: var(--text);
      padding: 10px 12px;
      font-size: 14px;
      outline: none;
    }
    .split{
      display:grid; gap:10px;
    }
    @media(min-width:860px){ .split{ grid-template-columns: 1.3fr .7fr; } }
    .kbd{
      font-family: ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;
      font-size: 12px;
      color: var(--muted);
      border:1px solid var(--stroke);
      padding: 2px 8px;
      border-radius: 999px;
      background: rgba(2,6,23,.35);
    }
    .bank{
      display:flex; gap:6px; flex-wrap:wrap; margin-top: 6px;
    }
    .mini{
      font-size: 11px;
      color: var(--muted);
    }
    .divider{ height:1px; background: rgba(148,163,184,.18); margin: 10px 0; }
    .list{ margin:0; padding-left: 18px; color: var(--muted); font-size: 12px; line-height:1.35; }
    .list b{ color: var(--text); }
  </style>
</head>
<body>
  <div class="flash good" id="flashGood"></div>
  <div class="flash bad" id="flashBad"></div>

  <div class="app">
    <header>
      <div class="brand">
        <div class="logo"></div>
        <div>
          <h1>Ingl√™s R√°pido ‚Äî Turbo</h1>
          <div class="sub">Gamificado + Treinador inteligente (A1 ‚Üí C1) ‚Ä¢ Sem repeti√ß√£o</div>
        </div>
      </div>
      <nav>
        <button id="tabHome" class="active">In√≠cio</button>
        <button id="tabTrain">Treinar</button>
        <button id="tabReview">Revis√£o</button>
        <button id="tabSettings" class="ghost">‚öôÔ∏è</button>
      </nav>
    </header>

    <!-- HOME -->
    <section class="screen active" id="screenHome">
      <div class="stats">
        <div class="stat">
          <div class="k">XP</div>
          <div class="v" id="xpValue">0</div>
        </div>
        <div class="stat">
          <div class="k">Streak</div>
          <div class="v"><span id="streakValue">0</span> üî•</div>
        </div>
        <div class="stat">
          <div class="k">N√≠vel atual</div>
          <div class="v" id="levelValue">A1</div>
        </div>
      </div>

      <div class="grid two" style="margin-top:12px;">
        <div class="card">
          <div class="row space">
            <div>
              <div class="h2">Comece agora (modo jogo)</div>
              <div class="muted">Rounds curtos. Errou ‚Üí troca a quest√£o. Acertou ‚Üí sobe a dificuldade.</div>
            </div>
            <button class="primary" id="btnStartNow">Come√ßar</button>
          </div>

          <div class="divider"></div>

          <div class="row" style="gap:8px;">
            <span class="pill"><strong>Meta do dia</strong> ‚Ä¢ 10 rounds</span>
            <span class="pill"><strong>Sem repeti√ß√£o</strong> ‚Ä¢ sess√£o atual</span>
            <span class="pill"><strong>√Åudio</strong> ‚Ä¢ TTS</span>
            <span class="pill"><strong>Tipos</strong> ‚Ä¢ ABCDE / Digitar / Montar</span>
          </div>

          <div style="margin-top:10px;">
            <div class="row space">
              <div class="muted">Progresso de hoje</div>
              <div class="kbd"><span id="todayCount">0</span>/10</div>
            </div>
            <div class="progress" style="margin-top:6px;"><div id="todayBar"></div></div>
          </div>

          <div class="divider"></div>

          <div class="h3">Escolha o n√≠vel</div>
          <div class="bank" id="levelButtons"></div>

          <div class="muted" style="margin-top:8px;">
            Dica: voc√™ pode misturar tudo (trabalho, viagem, escola, cinema, cultura...) ‚Äî o app cuida do n√≠vel.
          </div>
        </div>

        <div class="card">
          <div class="h2">Como esse app ‚Äúpuxa pra aprender‚Äù</div>
          <ul class="list">
            <li><b>Mastery por habilidade</b>: cada erro baixa a barra daquela habilidade.</li>
            <li><b>Recupera√ß√£o autom√°tica</b>: errou 2x no mesmo alvo ‚Üí mini treino guiado.</li>
            <li><b>Sem repeti√ß√£o</b>: quest√µes s√£o geradas + embaralhadas, com controle de IDs usados.</li>
            <li><b>Feedback forte</b>: som + flash verde/vermelho + explica√ß√£o curta.</li>
          </ul>

          <div class="divider"></div>

          <div class="row space">
            <div>
              <div class="h3">Desafio r√°pido</div>
              <div class="muted">Fa√ßa 5 rounds sem errar</div>
            </div>
            <button id="btnChallenge" class="primary">Valendo</button>
          </div>

          <div style="margin-top:10px;">
            <div class="row space">
              <div class="muted">Mastery m√©dio (n√≠vel atual)</div>
              <div class="kbd" id="avgMastery">0%</div>
            </div>
            <div class="progress" style="margin-top:6px;"><div id="masteryBar"></div></div>
          </div>

        </div>
      </div>
    </section>

    <!-- TRAIN -->
    <section class="screen" id="screenTrain">
      <div class="card">
        <div class="row space">
          <div>
            <div class="h2" id="trainTitle">Treino ‚Ä¢ A1</div>
            <div class="muted" id="trainSubtitle">Rounds misturados e din√¢micos</div>
          </div>
          <div class="row">
            <button id="btnHear" class="secondary">üîä Ouvir</button>
            <button id="btnSkip" class="secondary">Trocar</button>
            <button id="btnBackHome" class="secondary">Voltar</button>
          </div>
        </div>

        <div class="qwrap" id="qWrap">
          <div class="qmeta">
            <div class="row" style="gap:6px;">
              <span class="tag"><b id="qLevel">A1</b></span>
              <span class="tag">Tema: <b id="qTheme">‚Äî</b></span>
              <span class="tag">Habilidade: <b id="qSkill">‚Äî</b></span>
              <span class="tag">Tipo: <b id="qType">‚Äî</b></span>
            </div>
            <span class="kbd">Round <span id="roundN">1</span></span>
          </div>

          <div class="big" id="qPT">‚Äî</div>
          <div class="prompt" id="qPrompt">‚Äî</div>

          <div class="en" id="qEN">‚Äî</div>

          <div id="mcqBlock">
            <div class="options" id="opts"></div>
          </div>

          <div id="typingBlock" style="display:none;">
            <div class="muted">Digite a resposta em ingl√™s (tolerante a pequenas varia√ß√µes).</div>
            <div class="inputRow">
              <input type="text" id="typingInput" placeholder="Digite aqui..." />
              <button class="primary" id="btnCheckTyping">Verificar</button>
            </div>
            <div class="muted mini" id="typingTip"></div>
          </div>

          <div id="orderBlock" style="display:none;">
            <div class="muted">Monte a frase clicando nas palavras na ordem correta.</div>
            <div class="bank" id="wordBank"></div>
            <div class="divider"></div>
            <div class="muted">Sua frase:</div>
            <div class="en" id="builtSentence">‚Äî</div>
            <div class="row" style="margin-top:8px;">
              <button class="secondary" id="btnUndoWord">Desfazer</button>
              <button class="secondary" id="btnClearWords">Limpar</button>
              <button class="primary" id="btnCheckOrder">Verificar</button>
            </div>
          </div>

          <div class="feedback" id="feedback" style="display:none;"></div>
        </div>

        <div class="divider"></div>

        <div class="row space">
          <div class="row" style="gap:8px;">
            <span class="pill">XP: <strong id="xpInRun">0</strong></span>
            <span class="pill">Acertos: <strong id="hitsInRun">0</strong></span>
            <span class="pill">Erros: <strong id="missInRun">0</strong></span>
          </div>
          <div class="row" style="gap:8px;">
            <button id="btnEndSession" class="danger">Encerrar</button>
          </div>
        </div>
      </div>
    </section>

    <!-- REVIEW -->
    <section class="screen" id="screenReview">
      <div class="card">
        <div class="row space">
          <div>
            <div class="h2">Revis√£o inteligente</div>
            <div class="muted">Foca nas habilidades que voc√™ mais errou (sem repetir).</div>
          </div>
          <div class="row">
            <button id="btnReviewStart" class="primary">Revisar agora</button>
            <button id="btnReviewBack" class="secondary">Voltar</button>
          </div>
        </div>

        <div class="divider"></div>

        <div class="muted">Top habilidades fracas (n√≠vel atual):</div>
        <div class="bank" id="weakSkills"></div>

        <div class="divider"></div>

        <div class="muted">Frases salvas para fixar (as que voc√™ errou e depois acertou):</div>
        <ul class="list" id="savedPhrases"></ul>
      </div>
    </section>

    <!-- SETTINGS -->
    <section class="screen" id="screenSettings">
      <div class="card">
        <div class="row space">
          <div>
            <div class="h2">Configura√ß√µes</div>
            <div class="muted">Ajuste √°udio, reset do banco e armazenamento local.</div>
          </div>
          <button id="btnSettingsBack" class="secondary">Voltar</button>
        </div>

        <div class="divider"></div>

        <div class="row space" style="align-items:flex-start;">
          <div style="max-width:720px;">
            <div class="h3">√Åudio (TTS)</div>
            <div class="muted">Se o ‚ÄúOuvir‚Äù n√£o falar no celular, toque em qualquer bot√£o primeiro e tente de novo (bloqueio do navegador).</div>
            <div class="row" style="margin-top:8px;">
              <button class="secondary" id="btnTestVoice">Testar voz</button>
              <button class="secondary" id="btnStopVoice">Parar voz</button>
              <span class="pill">Voz: <strong id="voiceName">auto</strong></span>
            </div>

            <div class="divider"></div>

            <div class="h3">Sem repeti√ß√£o (controle)</div>
            <ul class="list">
              <li>Na sess√£o atual, o app <b>n√£o repete</b> ID de quest√£o.</li>
              <li>Se voc√™ quiser ‚Äúzerar tudo‚Äù pra gerar novas combina√ß√µes, use o reset abaixo.</li>
            </ul>

            <div class="row" style="margin-top:10px;">
              <button class="danger" id="btnResetAll">Reset total (XP + banco + mastery)</button>
              <button class="secondary" id="btnResetBank">Reset s√≥ do banco (sem perder XP)</button>
            </div>
          </div>

          <div class="card" style="background: rgba(2,6,23,.25); border-style:dashed; max-width:320px;">
            <div class="h3">Premium (ideias prontas)</div>
            <ul class="list">
              <li>Voz com sotaques + di√°logos reais.</li>
              <li>Modo ‚ÄúDueto‚Äù (fala) com nota.</li>
              <li>Comunidade + desafios semanais.</li>
              <li>Plano di√°rio autom√°tico e ranking.</li>
            </ul>
          </div>
        </div>
      </div>
    </section>

  </div>

<script>
(() => {
  // ==========================
  // UTIL
  // ==========================
  const $ = (id) => document.getElementById(id);

  const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
  const pick = (arr) => arr[Math.floor(Math.random() * arr.length)];
  const shuffle = (arr) => {
    const a = arr.slice();
    for (let i=a.length-1; i>0; i--){
      const j = Math.floor(Math.random()*(i+1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  };
  const norm = (s) => (s || "")
    .toLowerCase()
    .replace(/[‚Äô']/g,"'")
    .replace(/[^a-z0-9\s\-\?]/g,"")
    .replace(/\s+/g," ")
    .trim();

  const todayKey = () => {
    const d = new Date();
    const y = d.getFullYear();
    const m = String(d.getMonth()+1).padStart(2,'0');
    const day = String(d.getDate()).padStart(2,'0');
    return `${y}-${m}-${day}`;
  };

  // ==========================
  // STORAGE
  // ==========================
  const store = {
    get(k, fallback){
      try{
        const v = localStorage.getItem(k);
        return v ? JSON.parse(v) : fallback;
      }catch{ return fallback; }
    },
    set(k, v){
      localStorage.setItem(k, JSON.stringify(v));
    }
  };

  const STATE_KEY = "eng_turbo_state_v3";
  const DEFAULT = {
    level: "A1",
    xp: 0,
    streak: 0,
    lastDay: null,
    todayRounds: 0,
    mastery: {}, // skillKey -> 0..100
    savedPhrases: [], // strings
    usedIdsByLevel: {}, // level -> {session:[ids], dayKey:{...} optional}
    audioEnabled: true,
  };

  let state = store.get(STATE_KEY, DEFAULT);
  // merge safety
  state = {...DEFAULT, ...state};
  state.mastery = state.mastery || {};
  state.savedPhrases = state.savedPhrases || [];
  state.usedIdsByLevel = state.usedIdsByLevel || {};

  // streak update
  const tk = todayKey();
  if (!state.lastDay){
    state.lastDay = tk;
    state.todayRounds = 0;
    store.set(STATE_KEY, state);
  } else if (state.lastDay !== tk){
    // if yesterday, streak++
    const last = new Date(state.lastDay + "T00:00:00");
    const now = new Date(tk + "T00:00:00");
    const diffDays = Math.round((now - last) / (1000*60*60*24));
    if (diffDays === 1){
      state.streak = (state.streak || 0) + 1;
    } else {
      state.streak = 0;
    }
    state.lastDay = tk;
    state.todayRounds = 0;
    store.set(STATE_KEY, state);
  }

  // ==========================
  // AUDIO: SFX + TTS
  // ==========================
  let audioCtx = null;
  function ensureAudio(){
    if (!audioCtx){
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    if (audioCtx.state === "suspended"){
      audioCtx.resume().catch(()=>{});
    }
  }
  function beep(type){
    // type: "good" | "bad"
    try{
      ensureAudio();
      const now = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.connect(g); g.connect(audioCtx.destination);

      if (type === "good"){
        o.type = "sine";
        o.frequency.setValueAtTime(880, now);
        o.frequency.exponentialRampToValueAtTime(1320, now + 0.12);
        g.gain.setValueAtTime(0.0001, now);
        g.gain.exponentialRampToValueAtTime(0.28, now + 0.02);
        g.gain.exponentialRampToValueAtTime(0.0001, now + 0.18);
        o.start(now); o.stop(now + 0.2);
      } else {
        o.type = "square";
        o.frequency.setValueAtTime(140, now);
        o.frequency.exponentialRampToValueAtTime(90, now + 0.12);
        g.gain.setValueAtTime(0.0001, now);
        g.gain.exponentialRampToValueAtTime(0.25, now + 0.02);
        g.gain.exponentialRampToValueAtTime(0.0001, now + 0.22);
        o.start(now); o.stop(now + 0.24);
      }
    }catch{}
  }

  function flash(type){
    const el = type === "good" ? $("flashGood") : $("flashBad");
    el.classList.add("show");
    setTimeout(()=> el.classList.remove("show"), 140);
  }

  let voices = [];
  function loadVoices(){
    voices = window.speechSynthesis ? window.speechSynthesis.getVoices() : [];
    const best =
      voices.find(v => /en(-|_)us/i.test(v.lang)) ||
      voices.find(v => /^en/i.test(v.lang)) ||
      voices[0];
    $("voiceName").textContent = best ? `${best.name} (${best.lang})` : "indispon√≠vel";
  }
  if (window.speechSynthesis){
    window.speechSynthesis.onvoiceschanged = loadVoices;
    loadVoices();
  }

  function speak(text){
    if (!state.audioEnabled) return;
    if (!window.speechSynthesis) return;
    try{
      window.speechSynthesis.cancel();
      const u = new SpeechSynthesisUtterance(text);
      const best =
        voices.find(v => /en(-|_)us/i.test(v.lang)) ||
        voices.find(v => /^en/i.test(v.lang));
      if (best) u.voice = best;
      u.lang = best ? best.lang : "en-US";
      u.rate = 0.95;
      u.pitch = 1.0;
      window.speechSynthesis.speak(u);
    }catch{}
  }
  function stopSpeak(){
    try{ window.speechSynthesis && window.speechSynthesis.cancel(); }catch{}
  }

  // ==========================
  // CONTENT GENERATION (NO REPETITION)
  // ==========================
  // Themes + slots to generate hundreds of unique questions per level
  const THEMES = [
    {k:"Trabalho", scenes:["reuni√£o","ch√£o de f√°brica","e-mail","turno","treinamento","seguran√ßa"]},
    {k:"Viagem", scenes:["aeroporto","hotel","mapa","taxi","check-in","passeio"]},
    {k:"Escola", scenes:["sala de aula","prova","biblioteca","trabalho em grupo","professor","colegas"]},
    {k:"Cinema", scenes:["filme","pipoca","trailer","ingresso","s√©rie","streaming"]},
    {k:"Casa", scenes:["cozinha","rotina","fam√≠lia","limpeza","conta","visita"]},
    {k:"Cidade", scenes:["rua","loja","restaurante","mercado","√¥nibus","parque"]},
    {k:"Cultura", scenes:["m√∫sica","show","esporte","internet","memes","not√≠cias"]},
    {k:"Seguran√ßa", scenes:["regras","EPI","procedimento","aten√ß√£o","risco","alerta"]},
  ];

  const PEOPLE = [
    {subj:"I", obj:"me", be:"am", do:"do"},
    {subj:"You", obj:"you", be:"are", do:"do"},
    {subj:"We", obj:"us", be:"are", do:"do"},
    {subj:"They", obj:"them", be:"are", do:"do"},
    {subj:"He", obj:"him", be:"is", do:"does"},
    {subj:"She", obj:"her", be:"is", do:"does"},
    {subj:"It", obj:"it", be:"is", do:"does"},
  ];

  const VERBS_A1 = [
    {v:"help", s:"helps", pt:"ajudar"},
    {v:"work", s:"works", pt:"trabalhar"},
    {v:"study", s:"studies", pt:"estudar"},
    {v:"go", s:"goes", pt:"ir"},
    {v:"like", s:"likes", pt:"gostar"},
    {v:"watch", s:"watches", pt:"assistir"},
    {v:"play", s:"plays", pt:"jogar"},
    {v:"read", s:"reads", pt:"ler"},
    {v:"drink", s:"drinks", pt:"beber"},
    {v:"live", s:"lives", pt:"morar"},
    {v:"need", s:"needs", pt:"precisar"},
    {v:"want", s:"wants", pt:"querer"},
    {v:"check", s:"checks", pt:"checar"},
    {v:"speak", s:"speaks", pt:"falar"},
  ];

  const TIME_WORDS = [
    {en:"every day", pt:"todo dia"},
    {en:"on weekends", pt:"nos fins de semana"},
    {en:"in the morning", pt:"de manh√£"},
    {en:"at night", pt:"√† noite"},
    {en:"after work", pt:"depois do trabalho"},
    {en:"on Fridays", pt:"√†s sextas"},
    {en:"on Sundays", pt:"aos domingos"},
  ];

  const PLACES = [
    {en:"at the office", pt:"no escrit√≥rio"},
    {en:"at school", pt:"na escola"},
    {en:"at home", pt:"em casa"},
    {en:"in the factory", pt:"na f√°brica"},
    {en:"at the airport", pt:"no aeroporto"},
    {en:"in the hotel", pt:"no hotel"},
    {en:"at the gym", pt:"na academia"},
    {en:"in the restaurant", pt:"no restaurante"},
  ];

  // Skill system (per level)
  const LEVELS = {
    A1: {
      label: "B√°sico A1",
      skills: [
        {k:"A1_PRESENT_IYOU", name:"Present Simple (I/You/We/They)"},
        {k:"A1_PRESENT_HESHE", name:"Present Simple (He/She/It +s)"},
        {k:"A1_NEG_DO", name:"Negativa (do/does + not)"},
        {k:"A1_Q_DO", name:"Perguntas (Do/Does)"},
        {k:"A1_BE", name:"Verb to be (am/is/are)"},
        {k:"A1_ORDER", name:"Ordem de palavras (frase simples)"},
      ]
    },
    A2: {
      label: "Pr√©-Intermedi√°rio A2",
      skills: [
        {k:"A2_PAST", name:"Past Simple (regular/irregular comum)"},
        {k:"A2_PLANS", name:"Planos (going to)"},
        {k:"A2_COMPARE", name:"Comparativos (bigger / more)"},
        {k:"A2_MODAL", name:"Can/Can't + pedidos simples"},
        {k:"A2_ORDER", name:"Ordem em perguntas e negativas"},
      ]
    },
    B1: {
      label: "Intermedi√°rio B1",
      skills: [
        {k:"B1_STORY", name:"Story (past vs present)"},
        {k:"B1_OPINION", name:"Opini√£o (because/so/however)"},
        {k:"B1_WORK", name:"Trabalho (reuni√µes, prazos, e-mail)"},
        {k:"B1_PHRASAL", name:"Phrasal verbs comuns (pick up, turn on...)"},
      ]
    },
    B2: {
      label: "Pr√©-Avan√ßado B2",
      skills: [
        {k:"B2_NUANCE", name:"Nuance / tom (polite vs direct)"},
        {k:"B2_PASSIVE", name:"Passive voice (b√°sico)"},
        {k:"B2_COND", name:"Conditionals (if...)"},
      ]
    },
    C1: {
      label: "Avan√ßado C1",
      skills: [
        {k:"C1_DEBATE", name:"Debate (argumenta√ß√£o)"},
        {k:"C1_REWRITE", name:"Reescrita (mais natural)"},
        {k:"C1_LISTEN", name:"Listening dif√≠cil (simulado)"},
      ]
    }
  };

  // Mastery default
  function masteryKey(level, skillK){ return `${level}:${skillK}`; }
  function getMastery(level, skillK){
    const k = masteryKey(level, skillK);
    if (typeof state.mastery[k] !== "number") state.mastery[k] = 60; // start
    return state.mastery[k];
  }
  function bumpMastery(level, skillK, delta){
    const k = masteryKey(level, skillK);
    const cur = getMastery(level, skillK);
    state.mastery[k] = clamp(cur + delta, 0, 100);
  }
  function avgMastery(level){
    const skills = LEVELS[level].skills;
    const vals = skills.map(s => getMastery(level, s.k));
    const avg = vals.reduce((a,b)=>a+b,0)/vals.length;
    return Math.round(avg);
  }

  // Used IDs control (session no-repeat)
  function getUsed(level){
    state.usedIdsByLevel[level] = state.usedIdsByLevel[level] || { session: [], day: {} };
    const obj = state.usedIdsByLevel[level];
    obj.session = obj.session || [];
    return obj.session;
  }
  function markUsed(level, id){
    const used = getUsed(level);
    used.push(id);
  }
  function wasUsed(level, id){
    return getUsed(level).includes(id);
  }
  function resetBank(level){
    state.usedIdsByLevel[level] = state.usedIdsByLevel[level] || {};
    state.usedIdsByLevel[level].session = [];
  }

  // ==========================
  // QUESTION FACTORY
  // ==========================
  // We generate many unique questions by mixing:
  // - theme, scene, subject, verb, time, place, objects
  const OBJECTS = {
    trabalho: ["my team","the report","this meeting","my emails","the schedule","a new module"],
    viagem: ["my passport","the ticket","the hotel","the map","this flight","the reservation"],
    escola: ["English","this exercise","my homework","the lesson","my notebook","the test"],
    cinema: ["this movie","the trailer","that scene","the subtitles","the series","the actor"],
    casa: ["dinner","coffee","the house","my family","the bills","my routine"],
    cidade: ["the bus","this store","the restaurant","the park","the market","the street"],
    cultura: ["music","this song","the news","a podcast","the internet","this meme"],
    seguranca: ["safety rules","my PPE","this procedure","the risk","this warning","the checklist"],
  };

  const IRREG_PAST = [
    {base:"go", past:"went", pt:"ir"},
    {base:"eat", past:"ate", pt:"comer"},
    {base:"see", past:"saw", pt:"ver"},
    {base:"have", past:"had", pt:"ter"},
    {base:"make", past:"made", pt:"fazer"},
    {base:"take", past:"took", pt:"pegar/levar"},
    {base:"get", past:"got", pt:"conseguir/pegar"},
    {base:"come", past:"came", pt:"vir"},
  ];
  const REG_PAST = [
    {base:"work", past:"worked"},
    {base:"study", past:"studied"},
    {base:"watch", past:"watched"},
    {base:"play", past:"played"},
    {base:"visit", past:"visited"},
    {base:"help", past:"helped"},
    {base:"check", past:"checked"},
  ];

  function makeId(parts){
    return parts.map(p=>String(p).replace(/\s+/g,"_").toLowerCase()).join("|");
  }

  function rotateCorrectIndex(seed){
    // deterministic-ish distribution for ABCDE
    // seed is a number; return 0..4
    return seed % 5;
  }

  function makeMCQ({id, level, theme, skillK, pt, prompt, en, hint, why, options, correctIndex, tts}){
    return {
      id, level, theme, skillK,
      type: "MCQ",
      pt, prompt, en,
      hint, why,
      options,
      correctIndex,
      tts: tts || en
    };
  }

  function makeTyping({id, level, theme, skillK, pt, prompt, en, answers, hint, why, tts}){
    return {
      id, level, theme, skillK,
      type: "TYPING",
      pt, prompt, en,
      answers, // array of acceptable normalized answers
      hint, why,
      tts: tts || en
    };
  }

  function makeOrder({id, level, theme, skillK, pt, prompt, en, words, hint, why, tts}){
    return {
      id, level, theme, skillK,
      type: "ORDER",
      pt, prompt, en,
      words, // shuffled later
      hint, why,
      tts: tts || en
    };
  }

  function genA1Pool(maxCount = 420){
    const pool = [];
    // generate many combinations; keep unique by ID
    const seen = new Set();

    const themes = THEMES;
    let seed = 0;

    for (const th of themes){
      const tkey = th.k.toLowerCase();
      const objs = OBJECTS[tkey] || ["this"];
      for (const scene of th.scenes){
        for (const p of PEOPLE){
          const v = pick(VERBS_A1);
          const tw = pick(TIME_WORDS);
          const pl = pick(PLACES);
          seed++;

          // Skill selection by subject type
          const is3 = ["He","She","It"].includes(p.subj);
          const skillPS = is3 ? "A1_PRESENT_HESHE" : "A1_PRESENT_IYOU";

          // 1) Present simple correct form (MCQ)
          {
            const obj = pick(objs);
            const verb = is3 ? v.s : v.v;
            const en = `${p.subj} ${verb} ${obj} ${tw.en}.`;
            const pt = `Escolha a frase correta (${th.k} ‚Ä¢ ${scene}).`;
            const prompt = `Pense: quem faz a a√ß√£o? (${p.subj}) Isso muda o verbo?`;
            const hint = is3 ? `Dica: com he/she/it o verbo geralmente ganha "s".` : `Dica: com I/you/we/they o verbo fica na forma base.`;
            const why = is3
              ? `Com ${p.subj}, no Present Simple, usamos verbo +s (ex.: works, helps).`
              : `Com ${p.subj}, no Present Simple, usamos o verbo base (sem "s").`;

            const wrong1 = `${p.subj} ${v.v} ${obj} ${tw.en}.`; // missing s
            const wrong2 = `${p.subj} am ${v.v}ing ${obj} ${tw.en}.`.replace("am", p.be); // continuous wrong
            const wrong3 = `${p.subj} ${v.v}ed ${obj} ${tw.en}.`; // fake past
            const wrong4 = `${p.subj} ${v.v} ${obj} now.`; // time mismatch but acceptable distractor

            const correct = en;
            const raw = shuffle([correct, wrong1, wrong2, wrong3, wrong4]);

            // force A-E rotation: choose which slot is correct
            const desired = rotateCorrectIndex(seed);
            // put correct in desired slot
            raw.splice(raw.indexOf(correct), 1);
            const options = [];
            for (let i=0;i<5;i++){
              options[i] = (i===desired) ? correct : raw.pop();
            }

            const id = makeId(["A1", th.k, scene, "PS", p.subj, v.v, obj, tw.en, pl.en, seed]);
            if (!seen.has(id)){
              seen.add(id);
              pool.push(makeMCQ({
                id, level:"A1", theme:th.k, skillK: skillPS,
                pt, prompt,
                en: correct,
                hint, why,
                options,
                correctIndex: desired,
                tts: `${p.subj} ${verb} ${obj} ${tw.en}`
              }));
            }
          }

          // 2) Negative do/does (MCQ)
          {
            seed++;
            const obj = pick(objs);
            const aux = is3 ? "does not" : "do not";
            const en = `${p.subj} ${aux} ${v.v} ${obj}.`;
            const pt = `Como dizer a negativa corretamente (${th.k} ‚Ä¢ ${scene})?`;
            const prompt = `Observe o auxiliar: com ${p.subj} usamos ${is3 ? "does" : "do"}.`;
            const hint = `Dica: na negativa, o "s" vai no auxiliar (does), e o verbo principal volta ao base.`;
            const why = is3
              ? `Com ${p.subj}, a negativa usa "does not" + verbo base (ex.: does not work).`
              : `Com ${p.subj}, a negativa usa "do not" + verbo base.`;

            const wrong1 = `${p.subj} not ${v.v} ${obj}.`;
            const wrong2 = `${p.subj} ${is3 ? "do not" : "does not"} ${v.v} ${obj}.`;
            const wrong3 = `${p.subj} ${aux} ${v.s} ${obj}.`; // should be base
            const wrong4 = `${p.subj} don't ${v.v} ${obj}.`; // contraction; could be OK, but keep as distractor (we want full form)
            const correct = en;

            const raw = shuffle([correct, wrong1, wrong2, wrong3, wrong4]);
            const desired = rotateCorrectIndex(seed);
            raw.splice(raw.indexOf(correct), 1);
            const options = [];
            for (let i=0;i<5;i++){
              options[i] = (i===desired) ? correct : raw.pop();
            }

            const id = makeId(["A1", th.k, scene, "NEG", p.subj, v.v, obj, seed]);
            if (!seen.has(id)){
              seen.add(id);
              pool.push(makeMCQ({
                id, level:"A1", theme:th.k, skillK:"A1_NEG_DO",
                pt, prompt, en: correct,
                hint, why,
                options,
                correctIndex: desired,
                tts: `${p.subj} ${aux} ${v.v} ${obj}`
              }));
            }
          }

          // 3) Do/Does question (MCQ)
          {
            seed++;
            const obj = pick(objs);
            const aux = is3 ? "Does" : "Do";
            const en = `${aux} ${p.subj.toLowerCase()} ${v.v} ${obj}?`.replace("i", "I");
            const pt = `Escolha a pergunta correta (${th.k} ‚Ä¢ ${scene}).`;
            const prompt = `Perguntas no Present Simple usam auxiliar antes do sujeito.`;
            const hint = `Dica: ${aux} para ${is3 ? "he/she/it" : "I/you/we/they"}. Depois, verbo base.`;
            const why = `Estrutura: ${aux} + sujeito + verbo base + complemento.`;

            const wrong1 = `${p.subj} ${v.v} ${obj}?`;
            const wrong2 = `${aux} ${p.subj.toLowerCase()} ${v.s} ${obj}?`.replace("i", "I");
            const wrong3 = `Are ${p.subj.toLowerCase()} ${v.v}ing ${obj}?`.replace("i", "I");
            const wrong4 = `${aux} ${p.subj.toLowerCase()} ${v.v}ed ${obj}?`.replace("i", "I");

            const correct = en;
            const raw = shuffle([correct, wrong1, wrong2, wrong3, wrong4]);
            const desired = rotateCorrectIndex(seed);
            raw.splice(raw.indexOf(correct), 1);
            const options = [];
            for (let i=0;i<5;i++){
              options[i] = (i===desired) ? correct : raw.pop();
            }

            const id = makeId(["A1", th.k, scene, "Q", p.subj, v.v, obj, seed]);
            if (!seen.has(id)){
              seen.add(id);
              pool.push(makeMCQ({
                id, level:"A1", theme:th.k, skillK:"A1_Q_DO",
                pt, prompt, en: correct,
                hint, why, options,
                correctIndex: desired,
                tts: `${aux} ${p.subj.toLowerCase()} ${v.v} ${obj}`.replace("i", "I")
              }));
            }
          }

          // 4) Verb to be meaning (Typing)
          {
            seed++;
            const city = pick(["Brazil","S√£o Paulo","Piracicaba","Canada","Mexico","London"]);
            const be = p.be;
            const en = `${p.subj} ${be} from ${city}.`;
            const pt = `Digite a frase correta (origem) (${th.k} ‚Ä¢ ${scene}).`;
            const prompt = `Use verb to be: I am / You are / He is ...`;
            const hint = `Dica: escolha a forma do "to be" correta para "${p.subj}".`;
            const why = `No "to be": I am, you/we/they are, he/she/it is.`;

            const id = makeId(["A1", th.k, scene, "BEFROM", p.subj, city, seed]);
            if (!seen.has(id)){
              seen.add(id);
              pool.push(makeTyping({
                id, level:"A1", theme:th.k, skillK:"A1_BE",
                pt, prompt,
                en,
                answers: [norm(en)],
                hint, why,
                tts: `${p.subj} ${be} from ${city}`
              }));
            }
          }

          // 5) Order words (ORDER)
          {
            seed++;
            const obj = pick(objs);
            const verb = is3 ? v.s : v.v;
            const en = `${p.subj} ${verb} ${obj}.`;
            const pt = `Monte a frase (ordem correta) (${th.k} ‚Ä¢ ${scene}).`;
            const prompt = `Ordem padr√£o: sujeito + verbo + complemento.`;
            const hint = `Dica: comece pelo sujeito "${p.subj}".`;
            const why = `Ingl√™s √© bem fixo: Subject ‚Üí Verb ‚Üí Object.`;

            // words
            const words = `${p.subj} ${verb} ${obj}.`
              .replace(".","")
              .split(" ")
              .filter(Boolean);

            const id = makeId(["A1", th.k, scene, "ORDER", p.subj, verb, obj, seed]);
            if (!seen.has(id)){
              seen.add(id);
              pool.push(makeOrder({
                id, level:"A1", theme:th.k, skillK:"A1_ORDER",
                pt, prompt, en,
                words,
                hint, why,
                tts: `${p.subj} ${verb} ${obj}`
              }));
            }
          }

          if (pool.length >= maxCount) break;
        }
        if (pool.length >= maxCount) break;
      }
      if (pool.length >= maxCount) break;
    }
    return pool;
  }

  function genA2Pool(maxCount = 360){
    const pool = [];
    const seen = new Set();
    let seed = 1000;

    const themes = THEMES;

    for (const th of themes){
      for (const scene of th.scenes){
        seed++;

        // Past simple (MCQ)
        {
          const isIr = Math.random() < 0.55;
          const verb = isIr ? pick(IRREG_PAST) : pick(REG_PAST);
          const subj = pick(["I","We","They","He","She"]);
          const pt = `Escolha a frase no passado correta (${th.k} ‚Ä¢ ${scene}).`;
          const prompt = `Procure o marcador de passado (yesterday / last night / last week).`;
          const hint = `Dica: no passado, o verbo muda (worked / went).`;
          const why = isIr
            ? `Verbo irregular: ${verb.base} ‚Üí ${verb.past}.`
            : `Verbo regular: adiciona -ed (ex.: work ‚Üí worked).`;

          const time = pick(["yesterday","last night","last week","two days ago"]);
          const obj = pick(["to the park","to the office","home","a movie","a new place"]);
          const correct = `${subj} ${verb.past} ${obj} ${time}.`;

          const wrong1 = `${subj} ${verb.base} ${obj} ${time}.`;
          const wrong2 = `${subj} ${verb.past} ${obj} now.`;
          const wrong3 = `${subj} did ${verb.past} ${obj} ${time}.`;
          const wrong4 = `${subj} ${verb.base}ed ${obj} ${time}.`;

          const raw = shuffle([correct, wrong1, wrong2, wrong3, wrong4]);
          const desired = rotateCorrectIndex(seed);
          raw.splice(raw.indexOf(correct), 1);
          const options = [];
          for (let i=0;i<5;i++){
            options[i] = (i===desired) ? correct : raw.pop();
          }

          const id = makeId(["A2", th.k, scene, "PAST", subj, verb.base, obj, time, seed]);
          if (!seen.has(id)){
            seen.add(id);
            pool.push(makeMCQ({
              id, level:"A2", theme:th.k, skillK:"A2_PAST",
              pt, prompt, en: correct,
              hint, why, options,
              correctIndex: desired,
              tts: correct.replace(".","")
            }));
          }
        }

        // Going to plans (TYPING)
        {
          seed++;
          const subj = pick(["I","We","They","He","She"]);
          const place = pick(["to the airport","to the gym","to the meeting","to the cinema","to the store"]);
          const correct = `${subj} am going to go ${place} tomorrow.`
            .replace("I am", "I am")
            .replace("He am", "He is")
            .replace("She am", "She is")
            .replace("We am", "We are")
            .replace("They am", "They are");

          const pt = `Digite um plano com "going to" (${th.k} ‚Ä¢ ${scene}).`;
          const prompt = `Use: subject + am/is/are + going to + verb base.`;
          const hint = `Dica: "I am", "he/she is", "we/they are".`;
          const why = `Planos: am/is/are + going to + verbo base.`;

          const id = makeId(["A2", th.k, scene, "GOINGTO", subj, place, seed]);
          if (!seen.has(id)){
            seen.add(id);
            pool.push(makeTyping({
              id, level:"A2", theme:th.k, skillK:"A2_PLANS",
              pt, prompt, en: correct,
              answers: [norm(correct)],
              hint, why,
              tts: correct.replace(".","")
            }));
          }
        }

        // Can/can't (MCQ)
        {
          seed++;
          const subj = pick(["I","You","We","They","He","She"]);
          const verb = pick(["swim","drive","help","cook","speak English","use this app"]);
          const pt = `Escolha a frase correta com "can" (${th.k} ‚Ä¢ ${scene}).`;
          const prompt = `Depois de "can", o verbo fica na forma base.`;
          const hint = `Dica: "can" n√£o usa "to" e n√£o usa "s".`;
          const why = `Modal "can" + verbo base: "She can swim".`;

          const correct = `${subj} can ${verb}.`;
          const wrong1 = `${subj} can ${verb}s.`;
          const wrong2 = `${subj} can to ${verb}.`;
          const wrong3 = `${subj} am can ${verb}.`.replace("am", (subj==="I"?"am":(subj==="He"||subj==="She"?"is":"are")));
          const wrong4 = `${subj} can ${verb}ing.`;

          const raw = shuffle([correct, wrong1, wrong2, wrong3, wrong4]);
          const desired = rotateCorrectIndex(seed);
          raw.splice(raw.indexOf(correct), 1);
          const options = [];
          for (let i=0;i<5;i++){
            options[i] = (i===desired) ? correct : raw.pop();
          }

          const id = makeId(["A2", th.k, scene, "CAN", subj, verb, seed]);
          if (!seen.has(id)){
            seen.add(id);
            pool.push(makeMCQ({
              id, level:"A2", theme:th.k, skillK:"A2_MODAL",
              pt, prompt, en: correct,
              hint, why, options,
              correctIndex: desired,
              tts: correct.replace(".","")
            }));
          }
        }

        // Order (question order A2)
        {
          seed++;
          const wh = pick(["Where","When","What","How often"]);
          const subj = pick(["you","they","we","she","he"]);
          const aux = (subj==="she"||subj==="he") ? "do" : "do"; // keep simple A2, we'll use do; and does variation in B1
          const verb = pick(["go","work","study","meet","practice"]);
          const rest = pick(["on weekends","in the morning","today","after work","at night"]);
          const correct = `${wh} do ${subj} ${verb} ${rest}?`
            .replace("do she","does she")
            .replace("do he","does he");

          const pt = `Monte a pergunta (ordem correta) (${th.k} ‚Ä¢ ${scene}).`;
          const prompt = `Ordem: WH + do/does + sujeito + verbo base + complemento.`;
          const hint = `Dica: "does" para he/she.`;
          const why = `Perguntas A2: auxiliar antes do sujeito.`;

          const words = correct.replace("?","").split(" ").filter(Boolean);
          const id = makeId(["A2", th.k, scene, "ORDERQ", wh, subj, verb, rest, seed]);
          if (!seen.has(id)){
            seen.add(id);
            pool.push(makeOrder({
              id, level:"A2", theme:th.k, skillK:"A2_ORDER",
              pt, prompt, en: correct,
              words,
              hint, why,
              tts: correct.replace("?","")
            }));
          }
        }

        if (pool.length >= maxCount) break;
      }
      if (pool.length >= maxCount) break;
    }

    return pool;
  }

  function genB1Pool(maxCount = 240){
    const pool = [];
    const seen = new Set();
    let seed = 2000;

    const connectors = ["because","so","but","however"];
    const phrasals = [
      {v:"turn on", pt:"ligar"},
      {v:"turn off", pt:"desligar"},
      {v:"pick up", pt:"pegar/apanhar"},
      {v:"find out", pt:"descobrir"},
      {v:"set up", pt:"configurar"},
    ];

    for (const th of THEMES){
      for (const scene of th.scenes){
        seed++;

        // Opinion with connectors (MCQ)
        {
          const c = pick(connectors);
          const s1 = pick(["I like this plan","We need more time","They are late","The meeting is long"]);
          const s2 = pick(["it is clear","we have a deadline","traffic is bad","the data is missing"]);
          const correct = `${s1} ${c} ${s2}.`;
          const wrong1 = `${s1} ${c} to ${s2}.`;
          const wrong2 = `${s1} ${c} ${s2}?`;
          const wrong3 = `${s1} ${c} ${s2} now.`;
          const wrong4 = `${c} ${s1} ${s2}.`;

          const pt = `Escolha a frase mais natural (B1) (${th.k} ‚Ä¢ ${scene}).`;
          const prompt = `Conectores unem ideias. Escolha a ordem natural.`;
          const hint = `Dica: normalmente a frase come√ßa com a ideia principal.`;
          const why = `Estrutura natural: ideia 1 + conector + ideia 2.`;

          const raw = shuffle([correct, wrong1, wrong2, wrong3, wrong4]);
          const desired = rotateCorrectIndex(seed);
          raw.splice(raw.indexOf(correct), 1);
          const options = [];
          for (let i=0;i<5;i++){
            options[i] = (i===desired) ? correct : raw.pop();
          }

          const id = makeId(["B1", th.k, scene, "CONN", c, seed, s1, s2]);
          if (!seen.has(id)){
            seen.add(id);
            pool.push(makeMCQ({
              id, level:"B1", theme:th.k, skillK:"B1_OPINION",
              pt, prompt, en: correct,
              hint, why, options,
              correctIndex: desired,
              tts: correct.replace(".","")
            }));
          }
        }

        // Work email tone (Typing - rewrite)
        {
          seed++;
          const informal = pick([
            "Send me this now.",
            "I need the report today.",
            "Fix this.",
            "Call me."
          ]);
          const polite = pick([
            "Could you please send this today?",
            "Would you mind sharing the report today?",
            "Can you help me fix this, please?",
            "Could we have a quick call?"
          ]);

          const pt = `Digite uma vers√£o mais educada (B1) (${th.k} ‚Ä¢ ${scene}).`;
          const prompt = `Tente escrever de forma educada (polite).`;
          const hint = `Dica: use "Could you...?" / "Would you mind...?" / "please".`;
          const why = `No trabalho, "polite tone" aumenta clareza e colabora√ß√£o.`;

          const id = makeId(["B1", th.k, scene, "POLITE", seed, informal]);
          if (!seen.has(id)){
            seen.add(id);
            pool.push(makeTyping({
              id, level:"B1", theme:th.k, skillK:"B1_WORK",
              pt,
              prompt: `Transforme em algo educado: "${informal}"`,
              en: polite,
              answers: [norm(polite)], // simples (premium teria IA tolerante)
              hint, why,
              tts: polite
            }));
          }
        }

        // Phrasal verb (MCQ)
        {
          seed++;
          const p = pick(phrasals);
          const correct = `Please ${p.v} the lights.`;
          const wrong1 = `Please ${p.v} on the lights.`;
          const wrong2 = `Please ${p.v.replace(" ","")} the lights.`;
          const wrong3 = `Please ${p.v} the light.`;
          const wrong4 = `Please ${p.v} to the lights.`;

          const pt = `Escolha a frase correta (phrasal verb) (${th.k} ‚Ä¢ ${scene}).`;
          const prompt = `Phrasal verb funciona como ‚Äúverbo √∫nico‚Äù.`;
          const hint = `Dica: "${p.v}" = ${p.pt}.`;
          const why = `Phrasal verbs s√£o muito comuns em ingl√™s real.`;

          const raw = shuffle([correct, wrong1, wrong2, wrong3, wrong4]);
          const desired = rotateCorrectIndex(seed);
          raw.splice(raw.indexOf(correct), 1);
          const options = [];
          for (let i=0;i<5;i++){
            options[i] = (i===desired) ? correct : raw.pop();
          }

          const id = makeId(["B1", th.k, scene, "PHRASAL", seed, p.v]);
          if (!seen.has(id)){
            seen.add(id);
            pool.push(makeMCQ({
              id, level:"B1", theme:th.k, skillK:"B1_PHRASAL",
              pt, prompt, en: correct,
              hint, why, options,
              correctIndex: desired,
              tts: correct.replace(".","")
            }));
          }
        }

        if (pool.length >= maxCount) break;
      }
      if (pool.length >= maxCount) break;
    }

    return pool;
  }

  function genB2Pool(maxCount = 160){
    const pool = [];
    const seen = new Set();
    let seed = 3000;

    const passives = [
      {a:"They clean the room every day.", p:"The room is cleaned every day."},
      {a:"People use this tool in training.", p:"This tool is used in training."},
      {a:"They check the equipment weekly.", p:"The equipment is checked weekly."},
    ];

    for (const th of THEMES){
      for (const scene of th.scenes){
        seed++;

        // Passive (MCQ)
        {
          const item = pick(passives);
          const pt = `Escolha a forma passiva correta (B2) (${th.k} ‚Ä¢ ${scene}).`;
          const prompt = `Foco no objeto da a√ß√£o (passive voice).`;
          const hint = `Dica: passive = be + past participle (checked/used/cleaned).`;
          const why = `Passiva destaca o que foi feito, n√£o quem fez.`;

          const correct = item.p;
          const wrong1 = item.p.replace("is","are");
          const wrong2 = item.p.replace("cleaned","clean").replace("used","use").replace("checked","check");
          const wrong3 = item.a;
          const wrong4 = `The room cleaned every day.`;

          const raw = shuffle([correct, wrong1, wrong2, wrong3, wrong4]);
          const desired = rotateCorrectIndex(seed);
          raw.splice(raw.indexOf(correct), 1);
          const options = [];
          for (let i=0;i<5;i++){
            options[i] = (i===desired) ? correct : raw.pop();
          }

          const id = makeId(["B2", th.k, scene, "PASSIVE", seed, correct]);
          if (!seen.has(id)){
            seen.add(id);
            pool.push(makeMCQ({
              id, level:"B2", theme:th.k, skillK:"B2_PASSIVE",
              pt, prompt, en: correct,
              hint, why, options,
              correctIndex: desired,
              tts: correct.replace(".","")
            }));
          }
        }

        // Conditional (Typing)
        {
          seed++;
          const pt = `Complete a ideia (if...) (B2) (${th.k} ‚Ä¢ ${scene}).`;
          const prompt = `Escreva uma frase usando "If" + condi√ß√£o + resultado.`;
          const example = pick([
            "If I have time, I will practice English.",
            "If we leave early, we will arrive on time.",
            "If it rains, we will stay at home."
          ]);
          const hint = `Dica: If + present, will + base.`;
          const why = `Conditionals ajudam a falar de consequ√™ncias e planos.`;

          const id = makeId(["B2", th.k, scene, "COND", seed, example]);
          if (!seen.has(id)){
            seen.add(id);
            pool.push(makeTyping({
              id, level:"B2", theme:th.k, skillK:"B2_COND",
              pt,
              prompt: `Digite algo nesse padr√£o (ex.: "${example}")`,
              en: example,
              answers: [norm(example)],
              hint, why,
              tts: example
            }));
          }
        }

        if (pool.length >= maxCount) break;
      }
      if (pool.length >= maxCount) break;
    }

    return pool;
  }

  function genC1Pool(maxCount = 120){
    const pool = [];
    const seen = new Set();
    let seed = 4000;

    const debate = [
      {q:"Is technology making people more productive?", a:"In many cases, yes, because it automates repetitive tasks and saves time."},
      {q:"Should schools teach financial education?", a:"Yes, because it helps students make better decisions in real life."},
      {q:"Is remote work good for companies?", a:"It depends, but it can reduce costs and improve focus for many roles."}
    ];

    for (const d of debate){
      seed++;
      const pt = `Responda de forma clara (C1) ‚Äî digite uma resposta curta.`;
      const prompt = d.q;
      const hint = `Dica: use "because" ou "it depends".`;
      const why = `C1: clareza + argumento curto + conector.`;

      const id = makeId(["C1", "DEBATE", seed, d.q]);
      if (!seen.has(id)){
        seen.add(id);
        pool.push(makeTyping({
          id, level:"C1", theme:"Debate", skillK:"C1_DEBATE",
          pt, prompt, en: d.a,
          answers: [norm(d.a)],
          hint, why,
          tts: d.a
        }));
      }
      if (pool.length >= maxCount) break;
    }

    // Rewrites (MCQ)
    const rewrites = [
      {bad:"I want that you send me the file.", good:"I want you to send me the file."},
      {bad:"I have 44 years.", good:"I am 44 years old."},
      {bad:"I am agree with you.", good:"I agree with you."}
    ];
    for (const r of rewrites){
      seed++;
      const pt = `Escolha a forma natural (C1).`;
      const prompt = `Qual frase est√° mais natural?`;
      const hint = `Dica: algumas estruturas n√£o traduzem literal do portugu√™s.`;
      const why = `C1: naturalidade e collocations.`;

      const correct = r.good;
      const wrong1 = r.bad;
      const wrong2 = r.good.replace("I ","I am ");
      const wrong3 = r.good.replace("to send","send");
      const wrong4 = r.good + " now.";

      const raw = shuffle([correct, wrong1, wrong2, wrong3, wrong4]);
      const desired = rotateCorrectIndex(seed);
      raw.splice(raw.indexOf(correct), 1);
      const options = [];
      for (let i=0;i<5;i++){
        options[i] = (i===desired) ? correct : raw.pop();
      }

      const id = makeId(["C1", "REWRITE", seed, correct]);
      if (!seen.has(id)){
        seen.add(id);
        pool.push(makeMCQ({
          id, level:"C1", theme:"Natural", skillK:"C1_REWRITE",
          pt, prompt, en: correct,
          hint, why, options,
          correctIndex: desired,
          tts: correct
        }));
      }
      if (pool.length >= maxCount) break;
    }

    return pool;
  }

  // Pools cache (generated once per load)
  const POOLS = {
    A1: genA1Pool(520),
    A2: genA2Pool(420),
    B1: genB1Pool(280),
    B2: genB2Pool(180),
    C1: genC1Pool(120),
  };

  function poolFor(level){ return POOLS[level] || []; }

  // ==========================
  // UI NAV
  // ==========================
  const screens = {
    home: $("screenHome"),
    train: $("screenTrain"),
    review: $("screenReview"),
    settings: $("screenSettings"),
  };
  function show(screen){
    Object.values(screens).forEach(s=>s.classList.remove("active"));
    screens[screen].classList.add("active");

    $("tabHome").classList.toggle("active", screen==="home");
    $("tabTrain").classList.toggle("active", screen==="train");
    $("tabReview").classList.toggle("active", screen==="review");
    $("tabSettings").classList.toggle("active", screen==="settings");
  }

  $("tabHome").onclick = () => show("home");
  $("tabTrain").onclick = () => show("train");
  $("tabReview").onclick = () => show("review");
  $("tabSettings").onclick = () => show("settings");

  // ==========================
  // LEVEL BUTTONS
  // ==========================
  function renderLevelButtons(){
    const wrap = $("levelButtons");
    wrap.innerHTML = "";
    Object.keys(LEVELS).forEach(lvl=>{
      const b = document.createElement("button");
      b.textContent = `${lvl} ‚Ä¢ ${LEVELS[lvl].label}`;
      b.className = (state.level===lvl) ? "active" : "";
      b.onclick = ()=>{
        state.level = lvl;
        store.set(STATE_KEY, state);
        renderAll();
      };
      wrap.appendChild(b);
    });
  }

  // ==========================
  // TRAIN ENGINE
  // ==========================
  let run = {
    active: false,
    level: state.level,
    round: 0,
    hits: 0,
    miss: 0,
    xpGained: 0,
    challenge: false,
    challengeGoal: 5,
    challengeHits: 0,
    current: null,
    locked: false,
    recoveryMode: false,
    recoveryQueue: [],
    lastSkill: null,
  };

  function pickQuestion(level, mode){
    // mode: "normal" | "review"
    const pool = poolFor(level);
    if (!pool.length) return null;

    // build weighted candidates:
    // - prefer weak skills in review mode
    // - in normal mode: mix, but still favors weak
    const skills = LEVELS[level].skills.map(s=>s.k);

    const masteryMap = {};
    skills.forEach(sk => masteryMap[sk] = getMastery(level, sk));

    let targetSkill = null;
    if (mode === "review"){
      const sorted = skills.slice().sort((a,b)=> masteryMap[a] - masteryMap[b]);
      targetSkill = sorted[0];
    } else {
      // 60% chance pick from weaker half
      const sorted = skills.slice().sort((a,b)=> masteryMap[a] - masteryMap[b]);
      const weakHalf = sorted.slice(0, Math.ceil(sorted.length/2));
      targetSkill = (Math.random() < 0.6) ? pick(weakHalf) : pick(skills);
    }

    // recovery queue overrides
    if (run.recoveryMode && run.recoveryQueue.length){
      targetSkill = run.recoveryQueue[0];
    }

    // candidates by skill
    let candidates = pool.filter(q => q.skillK === targetSkill);

    // if not enough, fallback
    if (candidates.length < 10){
      candidates = pool.slice();
    }

    // no repetition in this session
    candidates = candidates.filter(q => !wasUsed(level, q.id));

    // if everything used, allow reset automatically
    if (!candidates.length){
      resetBank(level);
      candidates = pool.filter(q => !wasUsed(level, q.id));
      if (!candidates.length) candidates = pool.slice();
    }

    // pick
    const q = pick(candidates);

    // if in recovery, pop when asked
    run.lastSkill = q.skillK;
    return q;
  }

  function setTrainHeader(){
    const lvl = run.level;
    $("trainTitle").textContent = `Treino ‚Ä¢ ${lvl}`;
    const avg = avgMastery(lvl);
    $("trainSubtitle").textContent =
      run.challenge
        ? `Desafio: ${run.challengeHits}/${run.challengeGoal} sem errar ‚Ä¢ Mastery m√©dio: ${avg}%`
        : `Rounds misturados ‚Ä¢ Mastery m√©dio: ${avg}% ‚Ä¢ Banco: ${poolFor(lvl).length}+`;
  }

  function setQuestion(q){
    run.current = q;
    markUsed(run.level, q.id);

    // render meta
    $("qLevel").textContent = q.level;
    $("qTheme").textContent = q.theme;
    const skillName = LEVELS[q.level].skills.find(s=>s.k===q.skillK)?.name || q.skillK;
    $("qSkill").textContent = skillName;
    $("qType").textContent = q.type;

    // content
    $("qPT").textContent = q.pt;
    $("qPrompt").textContent = q.prompt;
    $("qEN").textContent = q.en;

    // blocks
    $("feedback").style.display = "none";
    $("feedback").className = "feedback";
    $("mcqBlock").style.display = "none";
    $("typingBlock").style.display = "none";
    $("orderBlock").style.display = "none";

    if (q.type === "MCQ"){
      $("mcqBlock").style.display = "block";
      renderOptions(q);
    } else if (q.type === "TYPING"){
      $("typingBlock").style.display = "block";
      $("typingInput").value = "";
      $("typingTip").textContent = q.hint;
    } else if (q.type === "ORDER"){
      $("orderBlock").style.display = "block";
      renderWordBank(q);
    }
  }

  function renderOptions(q){
    const opts = $("opts");
    opts.innerHTML = "";

    const letters = ["A","B","C","D","E"];
    q.options.forEach((txt, idx)=>{
      const b = document.createElement("button");
      b.className = "opt";
      b.innerHTML = `<span class="kbd">${letters[idx]}</span> ${txt}`;
      b.onclick = () => onAnswerMCQ(idx, b);
      opts.appendChild(b);
    });
  }

  let built = [];
  function renderWordBank(q){
    built = [];
    $("builtSentence").textContent = "‚Äî";
    const bank = $("wordBank");
    bank.innerHTML = "";
    const shuffled = shuffle(q.words);
    shuffled.forEach(w=>{
      const b = document.createElement("button");
      b.textContent = w;
      b.className = "secondary";
      b.onclick = ()=>{
        built.push(w);
        $("builtSentence").textContent = built.join(" ");
      };
      bank.appendChild(b);
    });
  }

  function showFeedback(kind, msg, hint, why){
    const fb = $("feedback");
    fb.style.display = "block";
    fb.classList.remove("good","bad");
    fb.classList.add(kind === "good" ? "good" : "bad");
    fb.innerHTML = `
      <div style="font-weight:900; margin-bottom:4px;">
        ${kind === "good" ? "‚úÖ Certo!" : "‚ùå Ops!"}
      </div>
      <div>${msg}</div>
      <div class="divider"></div>
      <div class="muted"><b>Dica:</b> ${hint || "‚Äî"}</div>
      <div class="muted" style="margin-top:4px;"><b>Por qu√™:</b> ${why || "‚Äî"}</div>
    `;
  }

  function awardXP(n){
    state.xp += n;
    run.xpGained += n;
  }

  function updateHUD(){
    $("xpValue").textContent = state.xp;
    $("streakValue").textContent = state.streak;
    $("levelValue").textContent = state.level;

    $("xpInRun").textContent = run.xpGained;
    $("hitsInRun").textContent = run.hits;
    $("missInRun").textContent = run.miss;

    $("roundN").textContent = run.round;
    $("todayCount").textContent = state.todayRounds;

    const pct = clamp((state.todayRounds/10)*100, 0, 100);
    $("todayBar").style.width = pct + "%";

    const avg = avgMastery(state.level);
    $("avgMastery").textContent = avg + "%";
    $("masteryBar").style.width = avg + "%";

    store.set(STATE_KEY, state);
  }

  function startSession({challenge=false, review=false}={}){
    run.active = true;
    run.level = state.level;
    run.round = 0;
    run.hits = 0;
    run.miss = 0;
    run.xpGained = 0;
    run.challenge = challenge;
    run.challengeHits = 0;
    run.recoveryMode = false;
    run.recoveryQueue = [];
    run.locked = false;

    setTrainHeader();
    nextQuestion(review ? "review" : "normal");
    show("train");
  }

  function endSession(){
    run.active = false;
    run.challenge = false;
    run.recoveryMode = false;
    run.recoveryQueue = [];
    stopSpeak();
    show("home");
    renderAll();
  }

  function nextQuestion(mode="normal"){
    if (run.locked) return;
    run.round += 1;
    setTrainHeader();

    const q = pickQuestion(run.level, mode);
    if (!q){
      showFeedback("bad","Sem quest√µes dispon√≠veis.","Tente resetar o banco.","‚Äî");
      return;
    }

    setQuestion(q);
    updateHUD();
  }

  function onCorrectBase(q){
    run.hits += 1;
    if (run.challenge){
      run.challengeHits += 1;
    }
    // XP
    awardXP(12);

    // Mastery up
    bumpMastery(q.level, q.skillK, +4);

    // Save phrase if it was wrong before and now corrected (simple rule: if miss>0 for this skill, store)
    if (run.miss > 0 && Math.random() < 0.35){
      const phrase = q.en;
      if (!state.savedPhrases.includes(phrase)){
        state.savedPhrases.unshift(phrase);
        state.savedPhrases = state.savedPhrases.slice(0, 30);
      }
    }

    beep("good");
    flash("good");
    state.todayRounds += 1;

    // Challenge success
    if (run.challenge && run.challengeHits >= run.challengeGoal){
      awardXP(60);
      beep("good");
      flash("good");
      showFeedback("good", `Desafio completo! +60 XP b√¥nus.`, "Agora mantenha a consist√™ncia.", "Voc√™ ficou sem errar no desafio.");
      updateHUD();
      setTimeout(()=> nextQuestion("normal"), 450);
      return;
    }

    updateHUD();
    setTimeout(()=> nextQuestion("normal"), 280);
  }

  // Recovery logic: err twice in same skill => 3 rounds forced in that skill
  const missTracker = {}; // skillK -> count
  function onWrongBase(q){
    run.miss += 1;
    beep("bad");
    flash("bad");
    awardXP(3); // still some XP to keep motivation

    bumpMastery(q.level, q.skillK, -7);

    missTracker[q.skillK] = (missTracker[q.skillK] || 0) + 1;

    // challenge fail on first mistake
    if (run.challenge){
      run.challenge = false;
      run.challengeHits = 0;
    }

    // enter recovery
    if (missTracker[q.skillK] >= 2 && !run.recoveryMode){
      run.recoveryMode = true;
      run.recoveryQueue = [q.skillK, q.skillK, q.skillK];
    }

    // consume recovery queue if active
    if (run.recoveryMode){
      if (run.recoveryQueue.length){
        run.recoveryQueue.shift();
      }
      if (!run.recoveryQueue.length){
        run.recoveryMode = false;
      }
    }

    updateHUD();

    // IMPORTANT: errou => troca a pergunta (n√£o repete)
    setTimeout(()=> nextQuestion(run.recoveryMode ? "review" : "normal"), 320);
  }

  function onAnswerMCQ(idx, btn){
    if (run.locked) return;
    run.locked = true;

    const q = run.current;
    const correct = q.correctIndex;

    // paint
    const optButtons = Array.from($("opts").querySelectorAll("button.opt"));
    optButtons.forEach((b, i)=>{
      if (i === correct) b.classList.add("correct");
      if (i === idx && idx !== correct) b.classList.add("wrong");
      b.disabled = true;
    });

    if (idx === correct){
      showFeedback("good", "Boa! Voc√™ acertou.", q.hint, q.why);
      // speak correct sentence (optional)
      speak(q.tts);
      run.locked = false;
      onCorrectBase(q);
    } else {
      showFeedback("bad", "Voc√™ errou ‚Äî beleza! Agora o app troca por outra quest√£o do mesmo alvo.", q.hint, q.why);
      speak(q.tts);
      run.locked = false;
      onWrongBase(q);
    }
  }

  $("btnCheckTyping").onclick = () => {
    if (run.locked) return;
    run.locked = true;
    const q = run.current;
    const ans = norm($("typingInput").value);
    const ok = q.answers.some(a => a === ans);

    if (ok){
      showFeedback("good", "Perfeito. √â isso a√≠.", q.hint, q.why);
      speak(q.tts);
      run.locked = false;
      onCorrectBase(q);
    } else {
      showFeedback("bad", "Ainda n√£o. Trocarei a quest√£o e voc√™ tenta de novo em outro cen√°rio.", q.hint, q.why);
      speak(q.tts);
      run.locked = false;
      onWrongBase(q);
    }
  };

  $("btnCheckOrder").onclick = () => {
    if (run.locked) return;
    run.locked = true;
    const q = run.current;
    const builtStr = built.join(" ").trim();
    const ok = norm(builtStr) === norm(q.en.replace(".","").replace("?",""));
    if (ok){
      showFeedback("good", "Ordem perfeita!", q.hint, q.why);
      speak(q.tts);
      run.locked = false;
      onCorrectBase(q);
    } else {
      showFeedback("bad", "Ordem n√£o ficou certa. Trocarei por outra do mesmo alvo.", q.hint, q.why);
      speak(q.tts);
      run.locked = false;
      onWrongBase(q);
    }
  };

  $("btnUndoWord").onclick = () => {
    built.pop();
    $("builtSentence").textContent = built.length ? built.join(" ") : "‚Äî";
  };
  $("btnClearWords").onclick = () => {
    built = [];
    $("builtSentence").textContent = "‚Äî";
  };

  // buttons
  $("btnHear").onclick = () => {
    const q = run.current;
    if (q) speak(q.tts);
  };
  $("btnSkip").onclick = () => {
    // swap question without penalty
    if (!run.active) return;
    nextQuestion("normal");
  };
  $("btnBackHome").onclick = () => endSession();
  $("btnEndSession").onclick = () => endSession();

  // Home actions
  $("btnStartNow").onclick = () => startSession({challenge:false});
  $("btnChallenge").onclick = () => startSession({challenge:true});
  $("btnStartDaily").onclick = () => startSession({challenge:false});
  $("btnGoReview").onclick = () => { show("review"); renderReview(); };
  $("btnQuickListening").onclick = () => startSession({challenge:false}); // keeps same; listening via hear
  $("btnContinueTrack") && ($("btnContinueTrack").onclick = () => startSession({challenge:false}));

  // Review
  $("btnReviewBack").onclick = () => show("home");
  $("btnReviewStart").onclick = () => {
    // start session in review mode (targets weakest skills)
    startSession({challenge:false, review:true});
  };

  // Settings
  $("btnSettingsBack").onclick = () => show("home");
  $("btnTestVoice").onclick = () => { ensureAudio(); speak("Hello! Let's practice English."); };
  $("btnStopVoice").onclick = () => stopSpeak();
  $("btnResetAll").onclick = () => {
    if (!confirm("Reset TOTAL? Vai zerar XP, streak, mastery e banco.")) return;
    state = JSON.parse(JSON.stringify(DEFAULT));
    state.level = "A1";
    state.lastDay = todayKey();
    store.set(STATE_KEY, state);
    resetBank("A1"); resetBank("A2"); resetBank("B1"); resetBank("B2"); resetBank("C1");
    renderAll();
    show("home");
  };
  $("btnResetBank").onclick = () => {
    if (!confirm("Resetar banco do n√≠vel atual? (n√£o perde XP)")) return;
    resetBank(state.level);
    store.set(STATE_KEY, state);
    renderAll();
  };

  // Top nav
  $("tabHome").onclick = ()=> { stopSpeak(); show("home"); renderAll(); };
  $("tabTrain").onclick = ()=> { stopSpeak(); show("train"); };
  $("tabReview").onclick = ()=> { stopSpeak(); show("review"); renderReview(); };
  $("tabSettings").onclick = ()=> { stopSpeak(); show("settings"); };

  // ==========================
  // REVIEW RENDER
  // ==========================
  function renderReview(){
    const lvl = state.level;
    const skills = LEVELS[lvl].skills.map(s=>({k:s.k, name:s.name, m:getMastery(lvl, s.k)}));
    skills.sort((a,b)=>a.m-b.m);
    const weak = skills.slice(0,4);

    const ws = $("weakSkills");
    ws.innerHTML = "";
    weak.forEach(x=>{
      const el = document.createElement("span");
      el.className = "pill";
      el.innerHTML = `<strong>${x.name}</strong> ‚Ä¢ ${x.m}%`;
      ws.appendChild(el);
    });

    const ul = $("savedPhrases");
    ul.innerHTML = "";
    (state.savedPhrases || []).slice(0,15).forEach(p=>{
      const li = document.createElement("li");
      li.textContent = p;
      ul.appendChild(li);
    });
  }

  // ==========================
  // RENDER ALL
  // ==========================
  function renderAll(){
    renderLevelButtons();
    updateHUD();
    renderReview();
  }

  renderAll();

})();
</script>
</body>
</html>